#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     HTcompass,           sensorI2CCustom)
#pragma config(Sensor, S3,     HTEOPD,              sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     backRight,     tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     backLeft,      tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     frontLeft,     tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     lifter,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    topGrabber,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    bottomGrabber,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//SET UP TEH MOTEHR CONFIGHS AND DELEUHT TEH SECERND LEEN IF EETS ABOUT SENSER MULTEPLEXER

#include "JoystickDriver.c"
#define FIELD FIELD_HOME
#include "PickleCompassDriver.c"
#include "PickleEOPDDriver.c"
#include "PickleServoDriver.c"


task main()
{
  nxtDisplayTextLine(2, "%x", topGrabber);
  //topServoStart(topGrabber);
  servo[srvo_S1_C4_1]=127;



servo[bottomGrabber]=12;


  loadCalibrationData();
  //Define what is forwards
  //setTarget(readTeleopForwards());
  setTarget(readCompass());
  //HTEOPDsetLongRange(HTEOPD);
  waitForStart();
  while (true)
  {
    nxtDisplayTextLine(3,"%d,%d",joystick.joy1_x1,joystick.joy1_y1);
    nxtDisplayTextLine(4,"%d",joystick.joy1_x2);
    getJoystickSettings(joystick);
    float mult=1.0;
    if (joy1Btn(5))
    {
      mult=(0.3); //Sets a value for a "slower speed" button, can be pushed to slow down movements of robot.
    }
    float r=sqrt(joystick.joy1_x1*joystick.joy1_x1+joystick.joy1_y1*joystick.joy1_y1);
    if (r>128) r=128;
    if (r<-128)r=-128;
    float r2=joystick.joy1_x2;
    // if(abs(joystick.joy1_x2) > 10)
    // {
    // motor[frontLeft] = flbr*mult-joystick.joy1_x2*mult;
    // motor[frontRight] = flbr*mult-joystick.joy1_x2*mult;
    // motor[backLeft] = frbl*mult+joystick.joy1_x2*mult;
    // motor[backRight] = frbl*mult+joystick.joy1_x2*mult;
    // }
    // else
    if(abs(r)<10)
    {
      r=0;
    }

    if(abs(r2)<10){
      r2=0;
    }

    //Convert to polar coordinates
    float theta=radiansToDegrees(atan(joystick.joy1_y1/joystick.joy1_x1));
    //Atan's range is too small
    if (joystick.joy1_x1 < 0)
    {
      theta=theta+180;
    }
    //Adjust for compass heading
    theta = theta + readRelativeCompass();
    //convert back to cartesian coordinates, although adjusted because the omni wheels
    //are at a 45 degree angle.
    float flbr=100*r*cosDegrees(45-theta)/128;
    float frbl=100*r*sinDegrees(45-theta)/128;
    if (true)//!isDetecting(HTEOPD))
    {
      nxtDisplayTextLine(2, "%d", HTEOPDreadRaw(HTEOPD));
      motor[frontLeft] = -flbr*mult+r2*mult;
      motor[frontRight] = -frbl*mult+r2*mult;
      motor[backLeft] = frbl*mult+r2*mult;
      motor[backRight] = flbr*mult+r2*mult;

    }
    else
    {
      motor[frontLeft] = r2*mult;
      motor[frontRight] = -r2*mult;
      motor[backLeft] = r2*mult;
      motor[backRight] = -r2*mult;
    }

    if (joy1Btn(6))
    {
      motor[lifter]=80;
    }
    else if (joy1Btn(8))
    {
      motor[lifter]=-80;
    }
    else
    {
      motor[lifter]=0;
    }
  }
}
