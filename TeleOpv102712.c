#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Motor,  mtr_S1_C1_1,     backRight,     tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     backLeft,      tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     frontLeft,     tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     lifter,    tmotorNormal, PIDControl, encoder);
#pragma config(Sensor, S2,     HTcompass,                  sensorI2CCustom)
#pragma config(Sensor, S3,     HTEOPD,                     sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//SET UP TEH MOTEHR CONFIGHS AND DELEUHT TEH SECERND LEEN IF EETS ABOUT SENSER MULTEPLEXER

#include "JoystickDriver.c"
#define FIELD FIELD_HOME
#include "PickleCompassDriver.c"
#include "PickleEOPDDriver.c"


task main()
{
  loadCalibrationData();
  //Define what is forwards
  //setTarget(readTeleopForwards());
  setTarget(readCompass());
  //HTEOPDsetLongRange(HTEOPD);
  waitForStart();
  while (true)
  {
    getJoystickSettings(joystick);
    float mult=1.0;
    if (joy1Btn(5))
    {
      mult=(0.3); //Sets a value for a "slower speed" button, can be pushed to slow down movements of robot.
    }
    float r=sqrt(joystick.joy1_x1*joystick.joy1_x1+joystick.joy1_y1*joystick.joy1_y1);
    float r2=sqrt(joystick.joy1_x2*joystick.joy.x2);
    // if(abs(joystick.joy1_x2) > 10)
    // {
    // motor[frontLeft] = flbr*mult-joystick.joy1_x2*mult;
    // motor[frontRight] = flbr*mult-joystick.joy1_x2*mult;
    // motor[backLeft] = frbl*mult+joystick.joy1_x2*mult;
    // motor[backRight] = frbl*mult+joystick.joy1_x2*mult;
    // }
    // else
    if(r<10 & r2<10)
    {
      motor[frontLeft] = 0;
      motor[frontRight] = 0;
      motor[backLeft] = 0;
      motor[backRight] = 0;
    }

    else
    {
      //Convert to polar coordinates
      float theta=radiansToDegrees(atan(joystick.joy1_y1/joystick.joy1_x1));
      //Atan's range is too small
      if (joystick.joy1_x1 < 0)
      {
        theta=theta+180;
      }
      //Adjust for compass heading
      theta = theta + readRelativeCompass();
      //convert back to cartesian coordinates, although adjusted because the omni wheels
      //are at a 45 degree angle.
      float flbr=100*r*cosDegrees(45-theta)/128;
      float frbl=100*r*sinDegrees(45-theta)/128;
      if (isDetecting(HTEOPD))
      {
        nxtDisplayTextLine(2, "%d", HTEOPDreadRaw(HTEOPD));
        if(abs(joystick.joy1_x2) > 10)
        {
          motor[frontLeft] = flbr*mult-joystick.joy1_x2*mult;
          motor[frontRight] = flbr*mult-joystick.joy1_x2*mult;
          motor[backLeft] = frbl*mult+joystick.joy1_x2*mult;
          motor[backRight] = frbl*mult+joystick.joy1_x2*mult;
        }
        else
        {
          motor[frontLeft]=flbr*mult;
          motor[backRight]=flbr*mult;
          motor[backLeft]=frbl*mult;
          motor[frontRight]=frbl*mult;
        }
      }
      else
      {
        motor[frontLeft] = -joystick.joy1_x2*mult;
        motor[frontRight] = -joystick.joy1_x2*mult;
        motor[backLeft] = joystick.joy1_x2*mult;
        motor[backRight] = joystick.joy1_x2*mult;
      }

      if (joy1Btn(6))
      {
        motor[lifter]=80;
      }
      else if (joy1Btn(8))
      {
        motor[lifter]=-80;
      }
      else
      {
        motor[lifter]=0;
      }
    }
  }
}
